[
  {
    "path": "posts/Knowledge_distillation_post/",
    "title": "Knowledge distillation with R and tensorflow",
    "description": "A quick tutorial on how to perform Knowledge distillation with R, in eager mode.",
    "author": [
      {
        "name": "Etienne Rolland",
        "url": "https://github.com/Cdk29"
      }
    ],
    "date": "2021-06-04",
    "categories": [],
    "contents": "\n\n\n\nWelcome\nHi everyone ! Welcome to my blog. Here I will just share some tutorials around things that were complicated for me, and for which others R users could be interested. Not surprisingly, lot of this tutorials will involve tensorflow or other deep learning things.\nSometimes things are possible in R, but, since our community is smaller, we don’t have that many resources or tutorials compared to the python community, explaining why it is cubersome to do some particuliar tasks in R, especially when the few tutorials available or interfaces packages start accumulate errors or bugs because they are not used often by an active community.\nI am not an expert, so I will try to source at maximum of my codes, or parameters when I can. I used a small size for the images to not blow my GPU, there is an example with fine tuning and a bigger GPU here.\nThere is probably a lack of optimization, but at least it is a working skeleton. If you have suggestion for improvement, comments are welcome :D\nAbout the data\nI wrote this code in the first place in the context of the Cassava Leaf Disease Classification, a Kaggle’s competition where the goal was to train a model to identify the disease on leafs of cassava. Here the distillation is made from an Efficientnet0 to an other one.\nWhat is knowledge distillation\nAs presented in this discussion thread on kaggle, knowledge distillation is defined as simply trains another individual model to match the output of an ensemble. Source. It is in fact slightly more complicated : the second neural net (student) will made predictions on the images, but then, the losses will be a function of its own loss as well as a loss based on the difference between his prediction and the one of its teacher or the ensemble.\nThis approach allow to compress an ensemble into one model and by then reduce the inference time, or, if trained to match the output of a model, to increase the overall performance of the model. I discover this approach by looking at the top solutions of the Plant Pathology 2020 competition, an other solution with computer vision and leaf, such as this one.\nI let you go to to this source mentioned aboved to understand how it could potentially works. It does not seems sure, but it seems related to the learning of specific features vs forcing the student to learn “multiple view”, multiple type of feature to detect in the images.\nThere is off course, no starting material to do it in R. Thanksfully there is a code example on the website of keras. In this example, they create a class of model, a distiller, to make the knowledge distillation. There is, however, one problem : model are not inheritable in R. There is example of inheritance with a R6 for callback, like here, but the models are not a R6 class. To overcome this problem, I used the code example as a guide, and reproduced the steps by following the approach in this guide for eager executation in keras with R. I took other code from the tensorflow website for R.\nThe code is quite hard to understand at first glance. The reason is, everything is executed in a single for loop, since everything is done in eager mode. It did not seemed possible to do it differently. So there is a lot of variable around to collect metrics during training. If you want to understand the code just remove it from the loop and run it outside of the for loop, before reconstructing the loop around. I did not used tfdataset as shown on the guide for eager execution, so instead of make_iterator_one_shot() and iterator_get_next(), here we loop over the train_generator to produce the batches.\n\n\nlibrary(tidyverse)\nlibrary(tensorflow)\ntf$executing_eagerly()\n\n\n[1] TRUE\n\n\n\ntensorflow::tf_version()\n\n\n[1] '2.3'\n\nHere I flex with my own version of keras. Basically, it is a fork with application wrapper for the efficient net.\nDisclaimer : I did not write the code for the really handy applications wrappers. It came from this commit for which the PR is hold until the fully release of tf 2.3, as stated in this PR. I am not sure why the PR is closed.\n\n\ndevtools::install_github(\"Cdk29/keras\", dependencies = FALSE)\n\n\n\n\n\nlibrary(keras)\n\n\n\n\n\nlabels<-read_csv('train.csv')\nhead(labels)\n\n\n# A tibble: 6 x 2\n  image_id       label\n  <chr>          <dbl>\n1 1000015157.jpg     0\n2 1000201771.jpg     3\n3 100042118.jpg      1\n4 1000723321.jpg     1\n5 1000812911.jpg     3\n6 1000837476.jpg     3\n\n\n\nlevels(as.factor(labels$label))\n\n\n[1] \"0\" \"1\" \"2\" \"3\" \"4\"\n\n\n\nidx0<-which(labels$label==0)\nidx1<-which(labels$label==1)\nidx2<-which(labels$label==2)\nidx3<-which(labels$label==3)\nidx4<-which(labels$label==4)\n\n\n\n\n\nlabels$CBB<-0\nlabels$CBSD<-0\nlabels$CGM<-0\nlabels$CMD<-0\nlabels$Healthy<-0\n\n\n\n\n\nlabels$CBB[idx0]<-1\nlabels$CBSD[idx1]<-1\nlabels$CGM[idx2]<-1\nlabels$CMD[idx3]<-1\n\n\n\n“Would it have been easier to create a function to convert the labelling ?” You may ask.\n\n\nlabels$Healthy[idx4]<-1\n\n\n\nProbably.\n\n\n#labels$label<-NULL\n\n\n\n\n\nhead(labels)\n\n\n# A tibble: 6 x 7\n  image_id       label   CBB  CBSD   CGM   CMD Healthy\n  <chr>          <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>\n1 1000015157.jpg     0     1     0     0     0       0\n2 1000201771.jpg     3     0     0     0     1       0\n3 100042118.jpg      1     0     1     0     0       0\n4 1000723321.jpg     1     0     1     0     0       0\n5 1000812911.jpg     3     0     0     0     1       0\n6 1000837476.jpg     3     0     0     0     1       0\n\n\n\nval_labels<-read_csv('validation_set.csv')\n\n\n\n\n\ntrain_labels<-labels[which(!labels$image_id %in% val_labels$image_id),]\n\n\n\n\n\ntable(train_labels$image_id %in% val_labels$image_id)\n\n\n\nFALSE \n19256 \n\n\n\ntrain_labels$label<-NULL\nval_labels$label<-NULL\n\nhead(train_labels)\n\n\n# A tibble: 6 x 6\n  image_id         CBB  CBSD   CGM   CMD Healthy\n  <chr>          <dbl> <dbl> <dbl> <dbl>   <dbl>\n1 1000015157.jpg     1     0     0     0       0\n2 1000201771.jpg     0     0     0     1       0\n3 100042118.jpg      0     1     0     0       0\n4 1000723321.jpg     0     1     0     0       0\n5 1000812911.jpg     0     0     0     1       0\n6 1000837476.jpg     0     0     0     1       0\n\nhead(val_labels)\n\n\n# A tibble: 6 x 6\n  image_id         CBB  CBSD   CGM   CMD Healthy\n  <chr>          <dbl> <dbl> <dbl> <dbl>   <dbl>\n1 1003442061.jpg     0     0     0     0       1\n2 1004672608.jpg     0     0     0     1       0\n3 1007891044.jpg     0     0     0     1       0\n4 1009845426.jpg     0     0     0     1       0\n5 1010648150.jpg     0     0     0     1       0\n6 1011139244.jpg     0     0     0     1       0\n\n\n\nimage_path<-'cassava-leaf-disease-classification/train_images/'\n\n\n\n\n\n#data augmentation\ndatagen <- image_data_generator(\n  rotation_range = 40,\n  width_shift_range = 0.2,\n  height_shift_range = 0.2,\n  shear_range = 0.2,\n  zoom_range = 0.5,\n  horizontal_flip = TRUE,\n  fill_mode = \"reflect\"\n)\n\n\n\n\n\nimg_path<-\"cassava-leaf-disease-classification/train_images/1000015157.jpg\"\n\nimg <- image_load(img_path, target_size = c(448, 448))\nimg_array <- image_to_array(img)\nimg_array <- array_reshape(img_array, c(1, 448, 448, 3))\nimg_array<-img_array/255\n# Generated that will flow augmented images\naugmentation_generator <- flow_images_from_data(\n  img_array, \n  generator = datagen, \n  batch_size = 1 \n)\nop <- par(mfrow = c(2, 2), pty = \"s\", mar = c(1, 0, 1, 0))\nfor (i in 1:4) {\n  batch <- generator_next(augmentation_generator)\n  plot(as.raster(batch[1,,,]))\n}\n\n\n\npar(op)\n\n\n\nData generator\nOkay so here is an interresting thing, I will try to compress the code to call a train generator to make it easier to call it.\nWhy ? Well, apparently a generator does not yield infinite batches, and the for loop of the distiller will stop working without obvious reason at epoch 7, when reaching the end of the validation generator.\nWhen we iterate over it, validation_generator yeld 8 images and 8 label, until the batch 267, than contains only 5 images (and create the bug when we try to add the loss of the batch to the loss of the epoch. Batch 268 does not exist. So solution seems to recreate on the fly the validation set and restart the iterations.\n\n\narg.list <- list(dataframe = val_labels, directory = image_path,\n                                              class_mode = \"other\",\n                                              x_col = \"image_id\",\n                                              y_col = c(\"CBB\",\"CBSD\", \"CGM\", \"CMD\", \"Healthy\"),\n                                              target_size = c(228, 228),\n                                              batch_size=8)\n\n\n\n\n\nvalidation_generator <- do.call(flow_images_from_dataframe, arg.list)\n\n\n\n\n\ndim(validation_generator[266][[1]])\n\n\n[1]   8 228 228   3\n\n\n\ndim(validation_generator[267][[1]])\n\n\n[1]   5 228 228   3\n\n\n\ndim(val_labels)\n\n\n[1] 2141    6\n\n\n\n2141/8\n\n\n[1] 267.625\n\n\n\ntrain_generator <- flow_images_from_dataframe(dataframe = train_labels, \n                                              directory = image_path,\n                                              generator = datagen,\n                                              class_mode = \"other\",\n                                              x_col = \"image_id\",\n                                              y_col = c(\"CBB\",\"CBSD\", \"CGM\", \"CMD\", \"Healthy\"),\n                                              target_size = c(228, 228),\n                                              batch_size=8)\n\nvalidation_generator <- flow_images_from_dataframe(dataframe = val_labels, \n                                              directory = image_path,\n                                              class_mode = \"other\",\n                                              x_col = \"image_id\",\n                                              y_col = c(\"CBB\",\"CBSD\", \"CGM\", \"CMD\", \"Healthy\"),\n                                              target_size = c(228, 228),\n                                              batch_size=8)\n\n\n\n\n\ntrain_generator\n\n\n<tensorflow.python.keras.preprocessing.image.DataFrameIterator>\n\n\n\nconv_base<-keras::application_efficientnet_b0(weights = \"imagenet\", include_top = FALSE, input_shape = c(228, 228, 3))\n\nfreeze_weights(conv_base)\n\nmodel <- keras_model_sequential() %>%\n    conv_base %>% \n    layer_global_max_pooling_2d() %>% \n    layer_batch_normalization() %>% \n    layer_dropout(rate=0.5) %>%\n    layer_dense(units=5, activation=\"softmax\")\n\n\n\n\n\n#unfreeze_weights(model, from = 'block5a_expand_conv')\nunfreeze_weights(conv_base, from = 'block5a_expand_conv')\n\n\n\n\n\nmodel %>% load_model_weights_hdf5(\"fine_tuned_eff_net_weights.15.hdf5\")\n\n\n\n\n\nsummary(model)\n\n\nModel: \"sequential\"\n______________________________________________________________________\nLayer (type)                   Output Shape                Param #    \n======================================================================\nefficientnetb0 (Functional)    (None, 8, 8, 1280)          4049571    \n______________________________________________________________________\nglobal_max_pooling2d (GlobalMa (None, 1280)                0          \n______________________________________________________________________\nbatch_normalization (BatchNorm (None, 1280)                5120       \n______________________________________________________________________\ndropout (Dropout)              (None, 1280)                0          \n______________________________________________________________________\ndense (Dense)                  (None, 5)                   6405       \n======================================================================\nTotal params: 4,061,096\nTrainable params: 3,707,853\nNon-trainable params: 353,243\n______________________________________________________________________\n\n\n\nconv_base_student<-keras::application_efficientnet_b0(weights = \"imagenet\", include_top = FALSE, input_shape = c(228, 228, 3))\n\nfreeze_weights(conv_base_student)\n\nstudent <- keras_model_sequential() %>%\n    conv_base_student %>% \n    layer_global_max_pooling_2d() %>% \n    layer_batch_normalization() %>% \n    layer_dropout(rate=0.5) %>%\n    layer_dense(units=5, activation=\"softmax\")\n\nstudent\n\n\nModel\nModel: \"sequential_1\"\n______________________________________________________________________\nLayer (type)                   Output Shape                Param #    \n======================================================================\nefficientnetb0 (Functional)    (None, 8, 8, 1280)          4049571    \n______________________________________________________________________\nglobal_max_pooling2d_1 (Global (None, 1280)                0          \n______________________________________________________________________\nbatch_normalization_1 (BatchNo (None, 1280)                5120       \n______________________________________________________________________\ndropout_1 (Dropout)            (None, 1280)                0          \n______________________________________________________________________\ndense_1 (Dense)                (None, 5)                   6405       \n======================================================================\nTotal params: 4,061,096\nTrainable params: 8,965\nNon-trainable params: 4,052,131\n______________________________________________________________________\n\nSource code and knowledge distillation\nSource code for knowledge distillation with Keras : https://keras.io/examples/vision/knowledge_distillation/\nHelp for eager executation details in R and various usefull code : https://keras.rstudio.com/articles/eager_guide.html\nOther source code in R : https://tensorflow.rstudio.com/tutorials/advanced/\nI am using an alpha parameter of 0.9 as suggested by this article.\n\n\ni=1\nalpha=0.9 #On_the_Efficacy_of_Knowledge_Distillation_ICCV_2019\ntemperature=3\n\n\n\n\n\noptimizer <- optimizer_adam()\n\n\n\n\n\ntrain_loss <- tf$keras$metrics$Mean(name='student_loss')\ntrain_accuracy <-  tf$keras$metrics$CategoricalAccuracy(name='train_accuracy')\n\n\n\n\n\nnb_epoch<-12\n\n\n\n\n\nnb_batch<-300\nval_step<-40\n\n\n\n\n\ntrain_loss_plot<-c()\naccuracy_plot<-c()\ndistilation_loss_plot <- c()\n\n\n\n\n\nval_loss_plot <- c()\nval_accuracy_plot <- c()\n\n\n\n\n\ncount_epoch<-0\n\n\n\n\n\nfor (epoch in 1:nb_epoch) {\n    cat(\"Epoch: \", epoch, \" -----------\\n\")\n    # Init metrics\n    train_loss_epoch <- 0\n    accuracies_on_epoch <- c()\n    distilation_loss_epoch <- 0\n    val_loss_epoch <- 0\n    val_accuaries_on_epoch <- c()\n    \n    #Formula to not see the same batch over and over on each epoch\n    #Count epoch instead of epoch\n    count_epoch<-count_epoch+1\n    idx_batch <- (1+nb_batch*(count_epoch-1)):(nb_batch*count_epoch)\n    idx_val_set <- (1+val_step*(count_epoch-1)):(val_step*count_epoch)\n    \n    #Dirty solution to restart on a new validation batch generator before reaching the end of the other one \n    if (as.integer((dim(val_labels)[1]/8)-1) %in% idx_val_set) {\n        count_epoch<-1\n        idx_val_set <- (1+val_step*(count_epoch-1)):(val_step*count_epoch)\n        validation_generator <- do.call(flow_images_from_dataframe, arg.list)\n    }\n    #need the same if for train generator\n    if (as.integer((dim(train_labels)[1]/8)-1) %in% idx_batch) {\n        count_epoch<-1\n        idx_batch <- (1+nb_batch*(count_epoch-1)):(nb_batch*count_epoch)\n        train_generator <- do.call(flow_images_from_dataframe, arg.list)\n    }\n    \n    for (batch in idx_batch) {\n        x = train_generator[batch][[1]]\n        y = train_generator[batch][[2]]\n        # Forward pass of teacher\n        teacher_predictions = model(x)\n\n        with(tf$GradientTape() %as% tape, {\n            student_predictions = student(x)\n            student_loss = tf$losses$categorical_crossentropy(y, student_predictions)\n        \n            distillation_loss = tf$losses$categorical_crossentropy(tf$nn$softmax(teacher_predictions/temperature, axis=0L), \n                                                           tf$nn$softmax(student_predictions/temperature, axis=0L))\n        \n            loss = alpha * student_loss + (1 - alpha) * distillation_loss\n            })\n        \n        # Compute gradients\n        # Variating learning rate :\n        # optimizer <- optimizer_adam(lr = 0.0001)\n        gradients <- tape$gradient(loss, student$trainable_variables)\n        optimizer$apply_gradients(purrr::transpose(list(gradients, student$trainable_variables)))\n        \n        #Collect the metrics of the student\n        train_loss_epoch <- train_loss_epoch + student_loss\n        distilation_loss_epoch <- distilation_loss_epoch + distillation_loss\n        \n        accuracy_on_batch <- train_accuracy(y_true=y, y_pred=student_predictions)\n        accuracies_on_epoch <- c(accuracies_on_epoch, as.numeric(accuracy_on_batch))\n        \n    }\n\n    #Collect info on current epoch and for graphs and cat()\n    train_loss_epoch <- mean(as.vector(as.numeric(train_loss_epoch))/nb_batch)\n    train_loss_plot <- c(train_loss_plot, train_loss_epoch)\n    \n    distilation_loss_epoch <- mean(as.vector(as.numeric(distilation_loss_epoch))/nb_batch)\n    distilation_loss_plot <- c(distilation_loss_plot, distilation_loss_epoch)\n    \n    accuracies_on_epoch <- mean(accuracies_on_epoch)\n    accuracy_plot <- c(accuracy_plot, accuracies_on_epoch)\n    \n    \n    for (step in idx_val_set) {\n        # Unpack the data\n        x = validation_generator[step][[1]]\n        y = validation_generator[step][[2]]\n\n        # Compute predictions\n        student_predictions = student(x)\n\n        # Calculate the loss\n        student_loss = tf$losses$categorical_crossentropy(y, student_predictions)\n\n        #Collect the metrics of the student\n        #This line will create a bug of shape when val_loss end.\n        val_loss_epoch <- val_loss_epoch + student_loss\n        \n        accuracy_on_val_step <- train_accuracy(y_true=y, y_pred=student_predictions)\n        val_accuaries_on_epoch <- c(val_accuaries_on_epoch, as.numeric(accuracy_on_val_step))\n    }\n    \n    #Collect info on current epoch and for graphs and cat()\n    val_loss_epoch <- mean(as.vector(as.numeric(val_loss_epoch))/val_step)\n    val_loss_plot <- c(val_loss_plot, val_loss_epoch)\n    \n    val_accuaries_on_epoch <- mean(val_accuaries_on_epoch)\n    val_accuracy_plot <- c(val_accuracy_plot, val_accuaries_on_epoch)\n    \n    #Plotting\n    cat(\"Total loss (epoch): \", epoch, \": \", train_loss_epoch, \"\\n\")\n    cat(\"Distillater loss : \", epoch, \": \", distilation_loss_epoch, \"\\n\")\n    cat(\"Accuracy (epoch): \", epoch, \": \", accuracies_on_epoch, \"\\n\")\n    cat(\"Val loss : \", epoch, \": \", val_loss_epoch, \"\\n\")\n    cat(\"Val Accuracy (epoch): \", epoch, \": \", val_accuaries_on_epoch, \"\\n\")\n}\n\n\nEpoch:  1  -----------\nTotal loss (epoch):  1 :  2.032698 \nDistillater loss :  1 :  1.006465 \nAccuracy (epoch):  1 :  0.4937743 \nVal loss :  1 :  1.99186 \nVal Accuracy (epoch):  1 :  0.5405847 \nEpoch:  2  -----------\nTotal loss (epoch):  2 :  1.637821 \nDistillater loss :  2 :  1.006225 \nAccuracy (epoch):  2 :  0.5521517 \nVal loss :  2 :  1.692116 \nVal Accuracy (epoch):  2 :  0.5638111 \nEpoch:  3  -----------\nTotal loss (epoch):  3 :  1.677892 \nDistillater loss :  3 :  1.006099 \nAccuracy (epoch):  3 :  0.5710151 \nVal loss :  3 :  2.137453 \nVal Accuracy (epoch):  3 :  0.5739829 \nEpoch:  4  -----------\nTotal loss (epoch):  4 :  1.482432 \nDistillater loss :  4 :  1.006041 \nAccuracy (epoch):  4 :  0.5802864 \nVal loss :  4 :  2.305705 \nVal Accuracy (epoch):  4 :  0.5843317 \nEpoch:  5  -----------\nTotal loss (epoch):  5 :  1.756785 \nDistillater loss :  5 :  1.00603 \nAccuracy (epoch):  5 :  0.5856595 \nVal loss :  5 :  1.410817 \nVal Accuracy (epoch):  5 :  0.5859433 \nEpoch:  6  -----------\nTotal loss (epoch):  6 :  1.48802 \nDistillater loss :  6 :  1.005898 \nAccuracy (epoch):  6 :  0.5891046 \nVal loss :  6 :  1.482232 \nVal Accuracy (epoch):  6 :  0.5922226 \nEpoch:  7  -----------\nTotal loss (epoch):  7 :  1.494214 \nDistillater loss :  7 :  1.005822 \nAccuracy (epoch):  7 :  0.5946783 \nVal loss :  7 :  2.049904 \nVal Accuracy (epoch):  7 :  0.5953036 \nEpoch:  8  -----------\nTotal loss (epoch):  8 :  1.482123 \nDistillater loss :  8 :  1.005879 \nAccuracy (epoch):  8 :  0.5962415 \nVal loss :  8 :  1.315619 \nVal Accuracy (epoch):  8 :  0.5987246 \nEpoch:  9  -----------\nTotal loss (epoch):  9 :  1.424837 \nDistillater loss :  9 :  1.005796 \nAccuracy (epoch):  9 :  0.6010982 \nVal loss :  9 :  1.460654 \nVal Accuracy (epoch):  9 :  0.6014284 \nEpoch:  10  -----------\nTotal loss (epoch):  10 :  1.290395 \nDistillater loss :  10 :  1.005878 \nAccuracy (epoch):  10 :  0.6045249 \nVal loss :  10 :  1.734818 \nVal Accuracy (epoch):  10 :  0.6062945 \nEpoch:  11  -----------\nTotal loss (epoch):  11 :  1.537157 \nDistillater loss :  11 :  1.005881 \nAccuracy (epoch):  11 :  0.6061626 \nVal loss :  11 :  1.187323 \nVal Accuracy (epoch):  11 :  0.6063426 \nEpoch:  12  -----------\nTotal loss (epoch):  12 :  1.280043 \nDistillater loss :  12 :  1.005716 \nAccuracy (epoch):  12 :  0.6079427 \nVal loss :  12 :  1.096315 \nVal Accuracy (epoch):  12 :  0.6096685 \n\nWhat about global_step = tf.train.get_or_create_global_step() describe here ? It seems to only refers to the number of batches seen by the graph. Source.\nPlotting\n\n\ntotal_loss_plot<-c()\n\n\n\n\n\n#instead of collecting them during the training : \ntotal_loss_plot <- alpha * train_loss_plot + (1 - alpha) * distilation_loss_plot\n\n\n\n\n\ndata <- data.frame(\"Student_loss\" = train_loss_plot, \n                    \"Distillation_loss\" = distilation_loss_plot,\n                   \"Total_loss\" = total_loss_plot,\n                    \"Epoch\" = 1:length(train_loss_plot),\n                    \"Val_loss\" = val_loss_plot,\n                    \"Train_accuracy\"= accuracy_plot,\n                    \"Val_accuracy\"= val_accuracy_plot)\n\n\n\n\n\nhead(data)\n\n\n  Student_loss Distillation_loss Total_loss Epoch Val_loss\n1     2.032698          1.006465   1.930074     1 1.991860\n2     1.637821          1.006225   1.574661     2 1.692116\n3     1.677892          1.006099   1.610713     3 2.137453\n4     1.482432          1.006041   1.434793     4 2.305705\n5     1.756785          1.006030   1.681710     5 1.410817\n6     1.488020          1.005898   1.439808     6 1.482232\n  Train_accuracy Val_accuracy\n1      0.4937743    0.5405847\n2      0.5521517    0.5638111\n3      0.5710151    0.5739829\n4      0.5802864    0.5843317\n5      0.5856595    0.5859433\n6      0.5891046    0.5922226\n\nWhere total_loss is alpha * train_loss_plot * (1 - alpha) * distilation_loss_plot\n\n\nggplot(data, aes(Epoch)) +\n  scale_colour_manual(values=c(Student_loss=\"#F8766D\",Val_loss=\"#00BFC4\", Distillation_loss=\"#DE8C00\", Total_loss=\"#1aff8c\")) +\n  geom_line(aes(y = Student_loss, colour = \"Student_loss\")) + \n  geom_line(aes(y = Val_loss, colour = \"Val_loss\")) + \n  geom_line(aes(y = Total_loss, colour = \"Total_loss\")) + \n  geom_line(aes(y = Distillation_loss, colour = \"Distillation_loss\"))\n\n\n\n#Validation set\nggplot(data, aes(Epoch)) + \n  geom_line(aes(y = Train_accuracy, colour = \"Train_accuracy\")) + \n  geom_line(aes(y = Val_accuracy, colour = \"Val_accuracy\"))\n\n\n\n\nFine tuning and conclusion\nIs that all ? Well, no. Here we perform knowledge distillation to teach to the head of the student network.\nThe next step would be to reproduce the knowledge distillation after unfreezing some part of the student, after writing something like :\n\n\nunfreeze_weights(conv_base_student, from = 'block5a_expand_conv')\n\n\n\nBut I will not bet my small GPU card on this or start a fire in my basement for the sake of the tutorial.\nAs I mentioned earlier, I readapted my code from kaggle, where the gpu is much bigger. Take a look if you want to see, but basically the end output looks like this :\nlossaccuracyWell, that’s it for this post, which is probably already lengthy enough for a blog post !\n\n\n\n",
    "preview": "posts/Knowledge_distillation_post/distill-preview.png",
    "last_modified": "2021-06-04T13:31:03+02:00",
    "input_file": "Knowledge-distillation-with-R-and-Keras.knit.md",
    "preview_width": 1248,
    "preview_height": 768
  }
]
