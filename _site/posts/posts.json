[
  {
    "path": "posts/segmenteR_post/",
    "title": "segmenteR, a small tool to segment a scientific article",
    "description": "segmenteR is a prototype package to segment scientific articles into their \ndifferent sections, such as material and methods.",
    "author": [
      {
        "name": "Etienne Rolland",
        "url": "https://github.com/Cdk29"
      }
    ],
    "date": "2021-06-11",
    "categories": [],
    "contents": "\nsegmenteR\nHi everyone ! Whether it is to perform systematic review, some data extraction, or a really specific project that requires it, you may need to extract a particular section from an scientific article in pdf format. If that is the case, you may be curious in this (prototype) R package, segmenteR, a tool to extract a section, for example, “material and methods”, from the pdf of an article, using the fonts information from the pdf and natural language processing.\nContext\nIt has been elaborated in the context of a research work conducted at the Joint Research Centre, Directorate F - Health, Consumers and Reference Materials, Ispra (VA), as a sub-part of a project that aimed to analyse a corpus of 801 articles, obtained from the PubMed MeSH database and related to several toxicity topics (cardiotoxicity, genotoxicity, etc).\nWe needed to extract both the material and methods section and the results section of each articles, to evaluate the quality of the reporting inside each articles and parse the texts for specific toxicity effects. The work has been published in the Journal of Applied Toxicology, Toxicity effects of nanomaterials for health applications: how automation can support systematic review of the literature ? Blanka Halamoda-Kenzaoui, Etienne Rolland, Jacopo Piovesan, Antonio Puertas Gallardo, Susanne Bremer-Hoffmann doi.org/10.1002/jat.4204.\nWhile this tool is a prototype, it has a small benchmark to evaluate its performances, as shown inside the article.\nRequirement\nTo extract the informations on the fonts inside the pdf we use Poppler, the PDF rendering library and its cpp API. SegmenteR require a version of poppler >= 0.89 as well as a recent version of pdftools. The dev version of pdftools integrate the required change, but you need to install it from github :\n\n\ndevtools::install_github(\"ropensci/pdftools\") \ndevtools::install_github(\"ec-jrc/jrc_f2_refine\", subdir=\"segmenteR\") \n\n\n\nGetting started\nThe short way\nDownload an open access article that was part of the corpus :\n\n\nurl <- ('https://www.cell.com/action/showPdf?pii=S1525-0016%2816%2931594-5')\ndownload.file(url, 'Abrams, M T et al 2010.pdf')\n\n\n\nWe need a model and from the library udpipe to tokenize and annotate the text :\n\n\n## got the model for annotation\ndl <- udpipe::udpipe_download_model(\"english-gum\")\nstr(dl)\n\n\n'data.frame':   1 obs. of  5 variables:\n $ language        : chr \"english-gum\"\n $ file_model      : chr \"/home/erolland/Bureau/casualR/_posts/segmenteR_post/english-gum-ud-2.5-191206.udpipe\"\n $ url             : chr \"https://raw.githubusercontent.com/jwijffels/udpipe.models.ud.2.5/master/inst/udpipe-ud-2.5-191206/english-gum-u\"| __truncated__\n $ download_failed : logi FALSE\n $ download_message: chr \"OK\"\n\n\n\nmodel <- udpipe::udpipe_load_model(file = dl$file_model)\n#model\n\n\n\n\n\nlibrary(segmenteR)\n## basic example code\n\nsection_aliases <- c(\"material\", \"method\", \"experimental\", \"experiment\", \"methodology\")\n\n#model definition can be skipped, the function can download it automatically\nmaterial_and_methods <- segmenteR::extract_section_from_pdf(pdf_name=\"Abrams, M T et al 2010.pdf\",\n                                                             udpipe_model=model, \n                                                             section_aliases=section_aliases)\n\nhead(unique(material_and_methods$sentence))\n\n\n[1] \"MAterIAls And Methods Animals.\"                                                                                                                                                                           \n[2] \"Female Crl:CD-1/ICR mice were obtained from Charles River (Wilmington, MA) and were between 6 and 10 weeks old at time of study (25–30 g).\"                                                               \n[3] \"All studies were performed in Merck Research Laboratories′\"                                                                                                                                               \n[4] \"AAALAC-accredited West Point, PA animal facility using protocols approved by the Institutional Animal Care and Use Committee.\"                                                                            \n[5] \"Liposome assemblies, siRNAs, and reagents.\"                                                                                                                                                               \n[6] \"siRNA Lipid Nanoparticles were assembled using a process involving simultaneous mixing of the lipid mixture in an ethanol solution with an aqueous solution of siRNA, followed by stepwise diafiltration.\"\n\nAnd shazam, you have (hopefully) your material and methods section in ConLL-U format inside the dataframe material_and_methods, a format suitable for parsing, etc. You can stop reading this blog entry here.\nA more in-depth example\nThis example show the inner working of the function extract_section_from_pdf(), and some functions you made need :\n\n\npdf_name <- \"Abrams, M T et al 2010.pdf\"\nremove_bibliography <- TRUE\n\ntxt_pdf <- tabulizer::extract_text(pdf_name) # read the text from the pdf\ntxt_pdf <- segmenteR::preprocess_article_txt(txt_pdf)\n\n\n\nThe role of the function annotate_txt_pdf() is to load the required model and use the library udpipe to tokenize and annotate the text. Please refer to the vignette or the excellent website of udpipe to get more details on the Conll-U format. The reason for this annotation is that we will need it to estimate where the section titles are the most likely placed. For example, if it is the first word of a sentence, if the the word of the sentence is also a section title, etc, it is probably a section title.\n\n\nconllu_df <- segmenteR::annotate_txt_pdf(txt_pdf, udpipe_model=model ) # create the dataframe for NLP using udpipe\nhead(conllu_df)\n\n\n  doc_id paragraph_id sentence_id\n1   doc1            1           1\n2   doc1            1           1\n3   doc1            1           1\n4   doc1            1           1\n5   doc1            1           1\n6   doc1            1           1\n                                                                              sentence\n1 original article© The American Society of Gene & Cell Therapy Molecular Therapy vol.\n2 original article© The American Society of Gene & Cell Therapy Molecular Therapy vol.\n3 original article© The American Society of Gene & Cell Therapy Molecular Therapy vol.\n4 original article© The American Society of Gene & Cell Therapy Molecular Therapy vol.\n5 original article© The American Society of Gene & Cell Therapy Molecular Therapy vol.\n6 original article© The American Society of Gene & Cell Therapy Molecular Therapy vol.\n  token_id    token    lemma  upos xpos                     feats\n1        1 original original   ADJ   JJ                Degree=Pos\n2        2 article© article©  NOUN   NN               Number=Sing\n3        3      The      the   DET   DT Definite=Def|PronType=Art\n4        4 American American PROPN  NNP               Number=Sing\n5        5  Society  Society PROPN  NNP               Number=Sing\n6        6       of       of   ADP   IN                      <NA>\n  head_token_id  dep_rel deps misc\n1             2     amod <NA> <NA>\n2            13 compound <NA> <NA>\n3             5      det <NA> <NA>\n4             5     amod <NA> <NA>\n5            13 compound <NA> <NA>\n6             7     case <NA> <NA>\n\nThe other informations we use, and the reason why we work directly on a pdf instead of a text, is the fonts information from the pdf, the font and the fontsize of the words inside the pdf. To do this we use poppler, a PDF rendering library and the cpp API of poppler. We extract this informations using a specific version of pdftools, reason why the package need a version of poppler > 0.89 as well as a recent version of pdftools.\n\n\npoppler_output <- segmenteR::prepare_poppler_output(pdf_name)\nhead(poppler_output)\n\n\n      Word             Font Size\n1        © AOJZVN+StoneSans  6.5\n2      The AOJZVN+StoneSans  6.5\n3 American AOJZVN+StoneSans  6.5\n4  Society AOJZVN+StoneSans  6.5\n5       of AOJZVN+StoneSans  6.5\n6     Gene AOJZVN+StoneSans  6.5\n\nThis informations is used to identify the probable font of the section, by first looking at the font used for the words Reference and Acknowledgment, that usually appear in only one occurrence in scientific articles :\n\n\nfont_section <- segmenteR::identify_font(poppler_output)\nprint(font_section)\n\n\n[1] \"VMUQDX+ITCStoneSans-Semibold\"\n\nKnowing this, we can know which sections are inside the articles and in which order they appear. The list under is the sections titles that the function will try to identify in the poppler output :\n\n\nlist_of_sections <- list(\n    c(\"Introduction\", \"INTRODUCTION\"),\n    c(\"Materials\", \"Material\", \"materials\", \"material\", \"MATERIALS\", \"MATERIAL\"),\n    c(\"Methods\", \"Method\", \"methods\", \"method\", \"METHODS\", \"METHOD\"),\n    c(\"Acknowledgements\", \"Acknowledgments\", \"ACKNOWLEDGEMENTS\", \"ACKNOWLEDGMENTS\",\n      \"Acknowledgement\", \"Acknowledgment\", \"ACKNOWLEDGEMENT\", \"ACKNOWLEDGMENT\"),\n    c(\"References\", \"REFERENCES\"),\n    c(\"Results\", \"RESULTS\"),\n    c(\"Discussion\", \"DISCUSSION\", \"discussion\"),\n    c(\"Abstract\", \"ABSTRACT\"),\n    c(\"Conclusions\", \"Conclusion\", \"CONCLUSION\", \"CONCLUSIONS\"),\n    c(\"Background\", \"BACKGROUND\"),\n    c(\"Experimental\", \"EXPERIMENTAL\", \"Experiment\"),\n    c(\"Supplementary\", \"SUPPLEMENTARY\"),\n    c(\"Methodology\"),\n    c(\"Appendix\"),\n    c(\"Section\", \"SECTION\")\n  )\n\n\n\nClean_font_txt() remove the most common font inside the articles, which improve the correct localization of the sections by create_section_title_df() inside the pdf.\n\n\npoppler_output <- segmenteR::clean_font_txt(poppler_output)\nhead(poppler_output)\n\n\n      Word             Font Size\n1        © AOJZVN+StoneSans  6.5\n2      The AOJZVN+StoneSans  6.5\n3 American AOJZVN+StoneSans  6.5\n4  Society AOJZVN+StoneSans  6.5\n5       of AOJZVN+StoneSans  6.5\n6     Gene AOJZVN+StoneSans  6.5\n\nSection_title_df is a dataframe that contain the section titles in the article and their relative order, based on the fonts information retrieved from the pdf. This informations (order and existence) will be used to localize the section in the ConLL-U format. This step is needed as the order and the composition of the sections title can change from one article to the other.\n\n\nsection_title_df <- segmenteR::create_section_title_df(font_section, list_of_sections, poppler_output)\nsection_title_df <- segmenteR::clean_title_journal(pdf_name, section_title_df)\nsection_title_df <- segmenteR::ad_hoc_reorder(section_title_df)\nhead(section_title_df)\n\n\n                Word                         Font Size\n293     Introduction VMUQDX+ITCStoneSans-Semibold 10.0\n1321         Results VMUQDX+ITCStoneSans-Semibold 10.0\n5243      Discussion VMUQDX+ITCStoneSans-Semibold 10.0\n6214       Materials VMUQDX+ITCStoneSans-Semibold 10.0\n6216         Methods VMUQDX+ITCStoneSans-Semibold 10.0\n7188 Acknowledgments VMUQDX+ITCStoneSans-Semibold  9.2\n\nRemoving the bibliography prevent some error in the localization in some sections, especially if a reference start with the word “material”. This option can be set to false.\n\n\nif (remove_bibliography == TRUE) {\n  conllu_df <- segmenteR::remove_bibliography_from_conllu(conllu_df, section_title_df)\n  section_title_df <- segmenteR::remove_reference_section_from_titles(section_title_df)\n}\n\n\n\nKnowing the relative order of the sections from one side, their names and the informations from the Conll-U dataframe (position inside the sentence, or the other words in the sentence) we can estimate the position of the different sections inside the Conll-U dataframe. Please note that the positions_sections_df is not the section_title_df, since section_title_df refer to the position inside the output from poppler, while section_title_df indicate the position inside the Conll-U dataframe.\n\n\npositions_sections_df <- segmenteR::locate_sections_position_in_conllu(conllu_df, section_title_df)\nsegmenteR::check_sections_df(positions_sections_df)\nhead(positions_sections_df)\n\n\n                section occurrences\n1          Introduction         239\n2               Results        1173\n3            Discussion        6295\n4 Materials and Methods        7563\n6       Acknowledgments        8769\n\n\n\nsection <- segmenteR::extract_section_from_conllu(conllu_df, positions_sections_df, section_aliases)\nhead(unique(section$sentence))\n\n\n[1] \"MAterIAls And Methods Animals.\"                                                                                                                                                                           \n[2] \"Female Crl:CD-1/ICR mice were obtained from Charles River (Wilmington, MA) and were between 6 and 10 weeks old at time of study (25–30 g).\"                                                               \n[3] \"All studies were performed in Merck Research Laboratories′\"                                                                                                                                               \n[4] \"AAALAC-accredited West Point, PA animal facility using protocols approved by the Institutional Animal Care and Use Committee.\"                                                                            \n[5] \"Liposome assemblies, siRNAs, and reagents.\"                                                                                                                                                               \n[6] \"siRNA Lipid Nanoparticles were assembled using a process involving simultaneous mixing of the lipid mixture in an ethanol solution with an aqueous solution of siRNA, followed by stepwise diafiltration.\"\n\nFinally extract_section_from_conllu() provide the section in ConLL-U format inside the dataframe section.\nKnown Gotchas\nDon’t use it on an article of two pages. Ever.\nGithub repository\nMore seriously, the extraction will fail on article of one or two pages, because of a function that remove sections names that have the same number of occurences than the numbers of pages, since some journals have names including “Materials”, or “Results”, wrote in the exact same fonts that the one of the sections titles. It would be something to improve in the definitive version of the package.\nIf you try this package for your project, by curiosity and have some comments or question, or if it does not work on your favorite article, feel free to open an issue on the github repository of the projet, I would be glad to take a look it.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-06-11T10:10:14+02:00",
    "input_file": "segmenteR.knit.md"
  },
  {
    "path": "posts/Knowledge_distillation_post/",
    "title": "Knowledge distillation with R and tensorflow",
    "description": "A quick tutorial on how to perform Knowledge distillation with R, in eager mode.",
    "author": [
      {
        "name": "Etienne Rolland",
        "url": "https://github.com/Cdk29"
      }
    ],
    "date": "2021-06-04",
    "categories": [],
    "contents": "\n\n\nknitr::opts_chunk$set(echo = TRUE)\n\n\n\nWelcome\nHi everyone ! Welcome to my blog. Here I will just share some tutorials around things that were complicated for me, and for which others R users could be interested. Not surprisingly, lot of this tutorials will involve tensorflow or other deep learning things.\nSometimes things are possible in R, but, since our community is smaller, we don’t have that many resources or tutorials compared to the python community, explaining why it is cubersome to do some particuliar tasks in R, especially when the few tutorials available or interfaces packages start accumulate errors or bugs because they are not used often by an active community.\nI am not an expert, so I will try to source at maximum of my codes, or parameters when I can. I used a small size for the images to not blow my GPU, there is an example with fine tuning and a bigger GPU here.\nThere is probably a lack of optimization, but at least it is a working skeleton. If you have suggestion for improvement, comments are welcome :D\nAbout the data\nI wrote this code in the first place in the context of the Cassava Leaf Disease Classification, a Kaggle’s competition where the goal was to train a model to identify the disease on leafs of cassava. Here the distillation is made from an Efficientnet0 to an other one.\nWhat is knowledge distillation\nAs presented in this discussion thread on kaggle, knowledge distillation is defined as simply trains another individual model to match the output of an ensemble. Source. It is in fact slightly more complicated : the second neural net (student) will made predictions on the images, but then, the losses will be a function of its own loss as well as a loss based on the difference between his prediction and the one of its teacher or the ensemble.\nThis approach allow to compress an ensemble into one model and by then reduce the inference time, or, if trained to match the output of a model, to increase the overall performance of the model. I discover this approach by looking at the top solutions of the Plant Pathology 2020 competition, an other solution with computer vision and leaf, such as this one.\nI let you go to to this source mentioned aboved to understand how it could potentially works. It does not seems sure, but it seems related to the learning of specific features vs forcing the student to learn “multiple view”, multiple type of feature to detect in the images.\nThere is off course, no starting material to do it in R. Thanksfully there is a code example on the website of keras. In this example, they create a class of model, a distiller, to make the knowledge distillation. There is, however, one problem : model are not inheritable in R. There is example of inheritance with a R6 for callback, like here, but the models are not a R6 class. To overcome this problem, I used the code example as a guide, and reproduced the steps by following the approach in this guide for eager executation in keras with R. I took other code from the tensorflow website for R.\nThe code is quite hard to understand at first glance. The reason is, everything is executed in a single for loop, since everything is done in eager mode. It did not seemed possible to do it differently. So there is a lot of variable around to collect metrics during training. If you want to understand the code just remove it from the loop and run it outside of the for loop, before reconstructing the loop around. I did not used tfdataset as shown on the guide for eager execution, so instead of make_iterator_one_shot() and iterator_get_next(), here we loop over the train_generator to produce the batches.\n\n\nlibrary(tidyverse)\nlibrary(tensorflow)\ntf$executing_eagerly()\n\n\n[1] TRUE\n\n\n\ntensorflow::tf_version()\n\n\n[1] '2.3'\n\nHere I flex with my own version of keras. Basically, it is a fork with application wrapper for the efficient net.\nDisclaimer : I did not write the code for the really handy applications wrappers. It came from this commit for which the PR is hold until the fully release of tf 2.3, as stated in this PR. I am not sure why the PR is closed.\n\n\ndevtools::install_github(\"Cdk29/keras\", dependencies = FALSE)\n\n\n\n\n\nlibrary(keras)\n\n\n\n\n\nlabels<-read_csv('train.csv')\nhead(labels)\n\n\n# A tibble: 6 x 2\n  image_id       label\n  <chr>          <dbl>\n1 1000015157.jpg     0\n2 1000201771.jpg     3\n3 100042118.jpg      1\n4 1000723321.jpg     1\n5 1000812911.jpg     3\n6 1000837476.jpg     3\n\n\n\nlevels(as.factor(labels$label))\n\n\n[1] \"0\" \"1\" \"2\" \"3\" \"4\"\n\n\n\nidx0<-which(labels$label==0)\nidx1<-which(labels$label==1)\nidx2<-which(labels$label==2)\nidx3<-which(labels$label==3)\nidx4<-which(labels$label==4)\n\n\n\n\n\nlabels$CBB<-0\nlabels$CBSD<-0\nlabels$CGM<-0\nlabels$CMD<-0\nlabels$Healthy<-0\n\n\n\n\n\nlabels$CBB[idx0]<-1\nlabels$CBSD[idx1]<-1\nlabels$CGM[idx2]<-1\nlabels$CMD[idx3]<-1\n\n\n\n“Would it have been easier to create a function to convert the labelling ?” You may ask.\n\n\nlabels$Healthy[idx4]<-1\n\n\n\nProbably.\n\n\n#labels$label<-NULL\n\n\n\n\n\nhead(labels)\n\n\n# A tibble: 6 x 7\n  image_id       label   CBB  CBSD   CGM   CMD Healthy\n  <chr>          <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>\n1 1000015157.jpg     0     1     0     0     0       0\n2 1000201771.jpg     3     0     0     0     1       0\n3 100042118.jpg      1     0     1     0     0       0\n4 1000723321.jpg     1     0     1     0     0       0\n5 1000812911.jpg     3     0     0     0     1       0\n6 1000837476.jpg     3     0     0     0     1       0\n\n\n\nval_labels<-read_csv('validation_set.csv')\n\n\n\n\n\ntrain_labels<-labels[which(!labels$image_id %in% val_labels$image_id),]\n\n\n\n\n\ntable(train_labels$image_id %in% val_labels$image_id)\n\n\n\nFALSE \n19256 \n\n\n\ntrain_labels$label<-NULL\nval_labels$label<-NULL\n\nhead(train_labels)\n\n\n# A tibble: 6 x 6\n  image_id         CBB  CBSD   CGM   CMD Healthy\n  <chr>          <dbl> <dbl> <dbl> <dbl>   <dbl>\n1 1000015157.jpg     1     0     0     0       0\n2 1000201771.jpg     0     0     0     1       0\n3 100042118.jpg      0     1     0     0       0\n4 1000723321.jpg     0     1     0     0       0\n5 1000812911.jpg     0     0     0     1       0\n6 1000837476.jpg     0     0     0     1       0\n\nhead(val_labels)\n\n\n# A tibble: 6 x 6\n  image_id         CBB  CBSD   CGM   CMD Healthy\n  <chr>          <dbl> <dbl> <dbl> <dbl>   <dbl>\n1 1003442061.jpg     0     0     0     0       1\n2 1004672608.jpg     0     0     0     1       0\n3 1007891044.jpg     0     0     0     1       0\n4 1009845426.jpg     0     0     0     1       0\n5 1010648150.jpg     0     0     0     1       0\n6 1011139244.jpg     0     0     0     1       0\n\n\n\nimage_path<-'cassava-leaf-disease-classification/train_images/'\n\n\n\n\n\n#data augmentation\ndatagen <- image_data_generator(\n  rotation_range = 40,\n  width_shift_range = 0.2,\n  height_shift_range = 0.2,\n  shear_range = 0.2,\n  zoom_range = 0.5,\n  horizontal_flip = TRUE,\n  fill_mode = \"reflect\"\n)\n\n\n\n\n\nimg_path<-\"cassava-leaf-disease-classification/train_images/1000015157.jpg\"\n\nimg <- image_load(img_path, target_size = c(448, 448))\nimg_array <- image_to_array(img)\nimg_array <- array_reshape(img_array, c(1, 448, 448, 3))\nimg_array<-img_array/255\n# Generated that will flow augmented images\naugmentation_generator <- flow_images_from_data(\n  img_array, \n  generator = datagen, \n  batch_size = 1 \n)\nop <- par(mfrow = c(2, 2), pty = \"s\", mar = c(1, 0, 1, 0))\nfor (i in 1:4) {\n  batch <- generator_next(augmentation_generator)\n  plot(as.raster(batch[1,,,]))\n}\n\n\n\npar(op)\n\n\n\nData generator\nOkay so here is an interresting thing, I will try to compress the code to call a train generator to make it easier to call it.\nWhy ? Well, apparently a generator does not yield infinite batches, and the for loop of the distiller will stop working without obvious reason at epoch 7, when reaching the end of the validation generator.\nWhen we iterate over it, validation_generator yeld 8 images and 8 label, until the batch 267, than contains only 5 images (and create the bug when we try to add the loss of the batch to the loss of the epoch. Batch 268 does not exist. So solution seems to recreate on the fly the validation set and restart the iterations.\n\n\narg.list <- list(dataframe = val_labels, directory = image_path,\n                                              class_mode = \"other\",\n                                              x_col = \"image_id\",\n                                              y_col = c(\"CBB\",\"CBSD\", \"CGM\", \"CMD\", \"Healthy\"),\n                                              target_size = c(228, 228),\n                                              batch_size=8)\n\n\n\n\n\nvalidation_generator <- do.call(flow_images_from_dataframe, arg.list)\n\n\n\n\n\ndim(validation_generator[266][[1]])\n\n\n[1]   8 228 228   3\n\n\n\ndim(validation_generator[267][[1]])\n\n\n[1]   5 228 228   3\n\n\n\ndim(val_labels)\n\n\n[1] 2141    6\n\n\n\n2141/8\n\n\n[1] 267.625\n\n\n\ntrain_generator <- flow_images_from_dataframe(dataframe = train_labels, \n                                              directory = image_path,\n                                              generator = datagen,\n                                              class_mode = \"other\",\n                                              x_col = \"image_id\",\n                                              y_col = c(\"CBB\",\"CBSD\", \"CGM\", \"CMD\", \"Healthy\"),\n                                              target_size = c(228, 228),\n                                              batch_size=8)\n\nvalidation_generator <- flow_images_from_dataframe(dataframe = val_labels, \n                                              directory = image_path,\n                                              class_mode = \"other\",\n                                              x_col = \"image_id\",\n                                              y_col = c(\"CBB\",\"CBSD\", \"CGM\", \"CMD\", \"Healthy\"),\n                                              target_size = c(228, 228),\n                                              batch_size=8)\n\n\n\n\n\ntrain_generator\n\n\n<tensorflow.python.keras.preprocessing.image.DataFrameIterator>\n\n\n\nconv_base<-keras::application_efficientnet_b0(weights = \"imagenet\", include_top = FALSE, input_shape = c(228, 228, 3))\n\nfreeze_weights(conv_base)\n\nmodel <- keras_model_sequential() %>%\n    conv_base %>% \n    layer_global_max_pooling_2d() %>% \n    layer_batch_normalization() %>% \n    layer_dropout(rate=0.5) %>%\n    layer_dense(units=5, activation=\"softmax\")\n\n\n\n\n\n#unfreeze_weights(model, from = 'block5a_expand_conv')\nunfreeze_weights(conv_base, from = 'block5a_expand_conv')\n\n\n\n\n\nmodel %>% load_model_weights_hdf5(\"fine_tuned_eff_net_weights.15.hdf5\")\n\n\n\n\n\nsummary(model)\n\n\nModel: \"sequential\"\n______________________________________________________________________\nLayer (type)                   Output Shape                Param #    \n======================================================================\nefficientnetb0 (Functional)    (None, 8, 8, 1280)          4049571    \n______________________________________________________________________\nglobal_max_pooling2d (GlobalMa (None, 1280)                0          \n______________________________________________________________________\nbatch_normalization (BatchNorm (None, 1280)                5120       \n______________________________________________________________________\ndropout (Dropout)              (None, 1280)                0          \n______________________________________________________________________\ndense (Dense)                  (None, 5)                   6405       \n======================================================================\nTotal params: 4,061,096\nTrainable params: 3,707,853\nNon-trainable params: 353,243\n______________________________________________________________________\n\n\n\nconv_base_student<-keras::application_efficientnet_b0(weights = \"imagenet\", include_top = FALSE, input_shape = c(228, 228, 3))\n\nfreeze_weights(conv_base_student)\n\nstudent <- keras_model_sequential() %>%\n    conv_base_student %>% \n    layer_global_max_pooling_2d() %>% \n    layer_batch_normalization() %>% \n    layer_dropout(rate=0.5) %>%\n    layer_dense(units=5, activation=\"softmax\")\n\nstudent\n\n\nModel\nModel: \"sequential_1\"\n______________________________________________________________________\nLayer (type)                   Output Shape                Param #    \n======================================================================\nefficientnetb0 (Functional)    (None, 8, 8, 1280)          4049571    \n______________________________________________________________________\nglobal_max_pooling2d_1 (Global (None, 1280)                0          \n______________________________________________________________________\nbatch_normalization_1 (BatchNo (None, 1280)                5120       \n______________________________________________________________________\ndropout_1 (Dropout)            (None, 1280)                0          \n______________________________________________________________________\ndense_1 (Dense)                (None, 5)                   6405       \n======================================================================\nTotal params: 4,061,096\nTrainable params: 8,965\nNon-trainable params: 4,052,131\n______________________________________________________________________\n\nSource code and knowledge distillation\nSource code for knowledge distillation with Keras : https://keras.io/examples/vision/knowledge_distillation/\nHelp for eager executation details in R and various usefull code : https://keras.rstudio.com/articles/eager_guide.html\nOther source code in R : https://tensorflow.rstudio.com/tutorials/advanced/\nI am using an alpha parameter of 0.9 as suggested by this article.\n\n\ni=1\nalpha=0.9 #On_the_Efficacy_of_Knowledge_Distillation_ICCV_2019\ntemperature=3\n\n\n\n\n\noptimizer <- optimizer_adam()\n\n\n\n\n\ntrain_loss <- tf$keras$metrics$Mean(name='student_loss')\ntrain_accuracy <-  tf$keras$metrics$CategoricalAccuracy(name='train_accuracy')\n\n\n\n\n\nnb_epoch<-12\n\n\n\n\n\nnb_batch<-300\nval_step<-40\n\n\n\n\n\ntrain_loss_plot<-c()\naccuracy_plot<-c()\ndistilation_loss_plot <- c()\n\n\n\n\n\nval_loss_plot <- c()\nval_accuracy_plot <- c()\n\n\n\n\n\ncount_epoch<-0\n\n\n\n\n\nfor (epoch in 1:nb_epoch) {\n    cat(\"Epoch: \", epoch, \" -----------\\n\")\n    # Init metrics\n    train_loss_epoch <- 0\n    accuracies_on_epoch <- c()\n    distilation_loss_epoch <- 0\n    val_loss_epoch <- 0\n    val_accuaries_on_epoch <- c()\n    \n    #Formula to not see the same batch over and over on each epoch\n    #Count epoch instead of epoch\n    count_epoch<-count_epoch+1\n    idx_batch <- (1+nb_batch*(count_epoch-1)):(nb_batch*count_epoch)\n    idx_val_set <- (1+val_step*(count_epoch-1)):(val_step*count_epoch)\n    \n    #Dirty solution to restart on a new validation batch generator before reaching the end of the other one \n    if (as.integer((dim(val_labels)[1]/8)-1) %in% idx_val_set) {\n        count_epoch<-1\n        idx_val_set <- (1+val_step*(count_epoch-1)):(val_step*count_epoch)\n        validation_generator <- do.call(flow_images_from_dataframe, arg.list)\n    }\n    #need the same if for train generator\n    if (as.integer((dim(train_labels)[1]/8)-1) %in% idx_batch) {\n        count_epoch<-1\n        idx_batch <- (1+nb_batch*(count_epoch-1)):(nb_batch*count_epoch)\n        train_generator <- do.call(flow_images_from_dataframe, arg.list)\n    }\n    \n    for (batch in idx_batch) {\n        x = train_generator[batch][[1]]\n        y = train_generator[batch][[2]]\n        # Forward pass of teacher\n        teacher_predictions = model(x)\n\n        with(tf$GradientTape() %as% tape, {\n            student_predictions = student(x)\n            student_loss = tf$losses$categorical_crossentropy(y, student_predictions)\n        \n            distillation_loss = tf$losses$categorical_crossentropy(tf$nn$softmax(teacher_predictions/temperature, axis=0L), \n                                                           tf$nn$softmax(student_predictions/temperature, axis=0L))\n        \n            loss = alpha * student_loss + (1 - alpha) * distillation_loss\n            })\n        \n        # Compute gradients\n        # Variating learning rate :\n        # optimizer <- optimizer_adam(lr = 0.0001)\n        gradients <- tape$gradient(loss, student$trainable_variables)\n        optimizer$apply_gradients(purrr::transpose(list(gradients, student$trainable_variables)))\n        \n        #Collect the metrics of the student\n        train_loss_epoch <- train_loss_epoch + student_loss\n        distilation_loss_epoch <- distilation_loss_epoch + distillation_loss\n        \n        accuracy_on_batch <- train_accuracy(y_true=y, y_pred=student_predictions)\n        accuracies_on_epoch <- c(accuracies_on_epoch, as.numeric(accuracy_on_batch))\n        \n    }\n\n    #Collect info on current epoch and for graphs and cat()\n    train_loss_epoch <- mean(as.vector(as.numeric(train_loss_epoch))/nb_batch)\n    train_loss_plot <- c(train_loss_plot, train_loss_epoch)\n    \n    distilation_loss_epoch <- mean(as.vector(as.numeric(distilation_loss_epoch))/nb_batch)\n    distilation_loss_plot <- c(distilation_loss_plot, distilation_loss_epoch)\n    \n    accuracies_on_epoch <- mean(accuracies_on_epoch)\n    accuracy_plot <- c(accuracy_plot, accuracies_on_epoch)\n    \n    \n    for (step in idx_val_set) {\n        # Unpack the data\n        x = validation_generator[step][[1]]\n        y = validation_generator[step][[2]]\n\n        # Compute predictions\n        student_predictions = student(x)\n\n        # Calculate the loss\n        student_loss = tf$losses$categorical_crossentropy(y, student_predictions)\n\n        #Collect the metrics of the student\n        #This line will create a bug of shape when val_loss end.\n        val_loss_epoch <- val_loss_epoch + student_loss\n        \n        accuracy_on_val_step <- train_accuracy(y_true=y, y_pred=student_predictions)\n        val_accuaries_on_epoch <- c(val_accuaries_on_epoch, as.numeric(accuracy_on_val_step))\n    }\n    \n    #Collect info on current epoch and for graphs and cat()\n    val_loss_epoch <- mean(as.vector(as.numeric(val_loss_epoch))/val_step)\n    val_loss_plot <- c(val_loss_plot, val_loss_epoch)\n    \n    val_accuaries_on_epoch <- mean(val_accuaries_on_epoch)\n    val_accuracy_plot <- c(val_accuracy_plot, val_accuaries_on_epoch)\n    \n    #Plotting\n    cat(\"Total loss (epoch): \", epoch, \": \", train_loss_epoch, \"\\n\")\n    cat(\"Distillater loss : \", epoch, \": \", distilation_loss_epoch, \"\\n\")\n    cat(\"Accuracy (epoch): \", epoch, \": \", accuracies_on_epoch, \"\\n\")\n    cat(\"Val loss : \", epoch, \": \", val_loss_epoch, \"\\n\")\n    cat(\"Val Accuracy (epoch): \", epoch, \": \", val_accuaries_on_epoch, \"\\n\")\n}\n\n\nEpoch:  1  -----------\nTotal loss (epoch):  1 :  1.970847 \nDistillater loss :  1 :  1.006515 \nAccuracy (epoch):  1 :  0.5028956 \nVal loss :  1 :  1.683065 \nVal Accuracy (epoch):  1 :  0.5337647 \nEpoch:  2  -----------\nTotal loss (epoch):  2 :  1.671758 \nDistillater loss :  2 :  1.006187 \nAccuracy (epoch):  2 :  0.5482197 \nVal loss :  2 :  1.746699 \nVal Accuracy (epoch):  2 :  0.5590533 \nEpoch:  3  -----------\nTotal loss (epoch):  3 :  1.618646 \nDistillater loss :  3 :  1.006112 \nAccuracy (epoch):  3 :  0.5649438 \nVal loss :  3 :  1.531488 \nVal Accuracy (epoch):  3 :  0.5679042 \nEpoch:  4  -----------\nTotal loss (epoch):  4 :  1.562328 \nDistillater loss :  4 :  1.005987 \nAccuracy (epoch):  4 :  0.575272 \nVal loss :  4 :  1.508584 \nVal Accuracy (epoch):  4 :  0.5776999 \nEpoch:  5  -----------\nTotal loss (epoch):  5 :  1.406053 \nDistillater loss :  5 :  1.005917 \nAccuracy (epoch):  5 :  0.5815135 \nVal loss :  5 :  1.372146 \nVal Accuracy (epoch):  5 :  0.5892469 \nEpoch:  6  -----------\nTotal loss (epoch):  6 :  1.520737 \nDistillater loss :  6 :  1.005878 \nAccuracy (epoch):  6 :  0.5893831 \nVal loss :  6 :  1.34237 \nVal Accuracy (epoch):  6 :  0.5902871 \nEpoch:  7  -----------\nTotal loss (epoch):  7 :  1.508101 \nDistillater loss :  7 :  1.005872 \nAccuracy (epoch):  7 :  0.5920453 \nVal loss :  7 :  2.097656 \nVal Accuracy (epoch):  7 :  0.5925921 \nEpoch:  8  -----------\nTotal loss (epoch):  8 :  1.267969 \nDistillater loss :  8 :  1.005815 \nAccuracy (epoch):  8 :  0.5949023 \nVal loss :  8 :  1.78513 \nVal Accuracy (epoch):  8 :  0.5982342 \nEpoch:  9  -----------\nTotal loss (epoch):  9 :  1.510699 \nDistillater loss :  9 :  1.005925 \nAccuracy (epoch):  9 :  0.5991197 \nVal loss :  9 :  1.387395 \nVal Accuracy (epoch):  9 :  0.5990839 \nEpoch:  10  -----------\nTotal loss (epoch):  10 :  1.495111 \nDistillater loss :  10 :  1.005821 \nAccuracy (epoch):  10 :  0.6014644 \nVal loss :  10 :  2.015202 \nVal Accuracy (epoch):  10 :  0.6017212 \nEpoch:  11  -----------\nTotal loss (epoch):  11 :  1.454717 \nDistillater loss :  11 :  1.00589 \nAccuracy (epoch):  11 :  0.6021615 \nVal loss :  11 :  1.659231 \nVal Accuracy (epoch):  11 :  0.6034705 \nEpoch:  12  -----------\nTotal loss (epoch):  12 :  1.37668 \nDistillater loss :  12 :  1.005826 \nAccuracy (epoch):  12 :  0.6035553 \nVal loss :  12 :  1.438908 \nVal Accuracy (epoch):  12 :  0.604799 \n\nWhat about global_step = tf.train.get_or_create_global_step() describe here ? It seems to only refers to the number of batches seen by the graph. Source.\nPlotting\n\n\ntotal_loss_plot<-c()\n\n\n\n\n\n#instead of collecting them during the training : \ntotal_loss_plot <- alpha * train_loss_plot + (1 - alpha) * distilation_loss_plot\n\n\n\n\n\ndata <- data.frame(\"Student_loss\" = train_loss_plot, \n                    \"Distillation_loss\" = distilation_loss_plot,\n                   \"Total_loss\" = total_loss_plot,\n                    \"Epoch\" = 1:length(train_loss_plot),\n                    \"Val_loss\" = val_loss_plot,\n                    \"Train_accuracy\"= accuracy_plot,\n                    \"Val_accuracy\"= val_accuracy_plot)\n\n\n\n\n\nhead(data)\n\n\n  Student_loss Distillation_loss Total_loss Epoch Val_loss\n1     1.970847          1.006515   1.874414     1 1.683065\n2     1.671758          1.006187   1.605201     2 1.746699\n3     1.618646          1.006112   1.557393     3 1.531488\n4     1.562328          1.005987   1.506694     4 1.508584\n5     1.406053          1.005917   1.366040     5 1.372146\n6     1.520737          1.005878   1.469251     6 1.342370\n  Train_accuracy Val_accuracy\n1      0.5028956    0.5337647\n2      0.5482197    0.5590533\n3      0.5649438    0.5679042\n4      0.5752720    0.5776999\n5      0.5815135    0.5892469\n6      0.5893831    0.5902871\n\nWhere total_loss is alpha * train_loss_plot * (1 - alpha) * distilation_loss_plot\n\n\nggplot(data, aes(Epoch)) +\n  scale_colour_manual(values=c(Student_loss=\"#F8766D\",Val_loss=\"#00BFC4\", Distillation_loss=\"#DE8C00\", Total_loss=\"#1aff8c\")) +\n  geom_line(aes(y = Student_loss, colour = \"Student_loss\")) + \n  geom_line(aes(y = Val_loss, colour = \"Val_loss\")) + \n  geom_line(aes(y = Total_loss, colour = \"Total_loss\")) + \n  geom_line(aes(y = Distillation_loss, colour = \"Distillation_loss\"))\n\n\n\n#Validation set\nggplot(data, aes(Epoch)) + \n  geom_line(aes(y = Train_accuracy, colour = \"Train_accuracy\")) + \n  geom_line(aes(y = Val_accuracy, colour = \"Val_accuracy\"))\n\n\n\n\nFine tuning and conclusion\nIs that all ? Well, no. Here we perform knowledge distillation to teach to the head of the student network.\nThe next step would be to reproduce the knowledge distillation after unfreezing some part of the student, after writing something like :\n\n\nunfreeze_weights(conv_base_student, from = 'block5a_expand_conv')\n\n\n\nBut I will not bet my small GPU card on this or start a fire in my basement for the sake of the tutorial.\nAs I mentioned earlier, I readapted my code from kaggle, where the gpu is much bigger. Take a look if you want to see, but basically the end output looks like this :\nlossaccuracyWell, that’s it for this post, which is probably already lengthy enough for a blog post !\n\n\n\n",
    "preview": "posts/Knowledge_distillation_post/distill-preview.png",
    "last_modified": "2021-06-04T20:16:53+02:00",
    "input_file": "Knowledge-distillation-with-R-and-Keras.knit.md",
    "preview_width": 1248,
    "preview_height": 768
  }
]
